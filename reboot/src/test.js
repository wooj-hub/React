// // const[재선언 불가], let[재선언]
// //기본타입[str,number,bool,un,null] vs 참조타입[obj,arr,fun]
// //기본타입[콜스택에서 값이 기본값(숫자,문자 등)이 담김]
// //참조타입[콜스택에서 값이 주소값이 담김]

// //콜스택:정적메모리
// //힙메모리:동적메모리

// //https://kimbangg.tistory.com/152

// //const a=1;
// //a는 평생 저기 1있는 곳(주소)를 평생 가리킴
// //메모리 [RAM]에 자리하나 빌려서 거기에 a= 1을 넣음

// //let a=1;
// //a=2;//새로운 값 2를 할당. a는 이제 다른 메모리 주소를 가리킴
// //메모리 주소가 변경됨.

// //메모리는 정적메모리(call stack)와 동적메모리(heap)로 나뉘는데
// //정적메모리는 기본타입들, 참조타입의 주소들이 저장되는데,
// //참조타입주소들은 동적메모리로 참조되어 값들이 다시 저장된다.

// //coffe[obj]는 참조타입이라 const로 선언해도 값을 바꿀수있음
// const coffee = { name: "아메리카노", price: 2000 };
// coffee.name = "라떼";
// console.log(coffee); // 라떼, 2000

// //리액트 불변성 원칙
// //랜더링이 일어나는 조건
// //주소값이 바뀌면 랜더링이 일어남. 랜더링이 일어나야 좋은거임

// const [num, setNum] = useState(1);
// const [coffee,setCoffee] = useState({name:"커피", price:2500})

// setNum(3); //주소값이 바뀜. 랜더링 일어남.
// //기본변수는 정적메모리에 값이 다 정해져있기때문에 값을 바꾸려면 주소값을 바꿔야함.

// setCoffee({name:"라떼",price:2500});
// //참조변수는 동적메모리에서 값을 저장하기 때문에
// //정적메모리의 주소값은 바뀌지 않음. 랜더링이 일어나지 않음
// //따라서 밑에 처럼 해줘야 랜더링이 일어남
// setCoffee(()=>{}) //참조타입 랜더링 조건

// setCoffee((v)=>({
//     const newObj = {...v,name:"라떼"};
//     return newObj // 이렇게 새로운 오브젝트를 선언해서 값을 바꿔줘야 랜더링 일어남
// }));
